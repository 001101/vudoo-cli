#!/usr/bin/env node
const program = require('commander');
const chalk = require('chalk');
const ora = require('ora');
const path = require('path');
const rm = require('rimraf').sync;
const fs = require('fs');
const download_repository = require('download-git-repo');
const shell = require('shelljs');
const generator = require('../lib/generator');
const inquirer = require('inquirer');
const local_path = require('../lib/local-path');

const exists = fs.existsSync;

program
	.version('0.0.1')
	.description('CLI application to generate templates for Odoo-Vue Integration')

program
    .command('init <module-name>')
    .description('Generate a new project from template')
    .option("-t, --template [type]", "specify template (odoo8|odoo9|odoo10|odoo11|simple)", "simple")
    .option("-d, --destination [path]", "Destination of the module", '.')
    .action((module_name, options) => {
        const template = options.template;
        const repository = generateNameRepository(template);
        const dest_generate = (options.destination === '.') ? path.resolve('.') : (options.destination);
        const full_path_project = path.join(dest_generate, module_name);

        inquirer.prompt([{
            type: 'confirm',
            message: dest_generate === '.'
              ? 'Generate project in current directory?'
              : 'Target directory exists. Continue?',
            name: 'ok'
        }]).then(answers => {
            if (answers.ok){
                download_template(repository, template)
                    .then(path_download => generate_template(module_name, path_download, dest_generate))
                    .catch(err => console.log('Failed to download ' + repository + ': ' + err.message.trim()))
            }
        }).catch(console.log);
    });

program
	.arguments('<command>')
	.action((cmd) => {
		program.outputHelp()
		console.log(`  ` + chalk.red(`Unknown command ${chalk.yellow(cmd)}.`))
		console.log()
	})

program
	.on('--help', () => {
		console.log()
		console.log(`  Run ${chalk.cyan(`vudoo-cli <command> --help`)} for detailed usage of given command.`)
		console.log()
	})

program.commands.forEach(
	c => c.on('--help', () => console.log())
)

function generateNameRepoitory(name){
    const main_repo = 'BMKeros/vudoo-templates';
    switch(name){
        case 'simple': return `${main_repo}#simple`;
        case 'odoo8': return `${main_repo}#odoo8`;
        case 'odoo9': return `${main_repo}#odoo9`
        case 'odoo10': return `${main_repo}#odoo10`;
        case 'odoo11': return `${main_repo}#odoo11`;
        default: return `${main_repo}#simple`;
    }
}

const download_template = (repo, template) => {
    const dest_download = path.join(local_path.baseTemplates(), template);

    return new Promise((resolve, reject) => {
        const spinner = ora('Downloading template from vudoo-templates');
        spinner.start();
        
        if (exists(dest_download)){
            rm(dest_download);
        }
        else{
            shell.mkdir('-p', dest_download);
        }

        download_repository(repo, dest_download, { clone: false }, err => {
            spinner.stop()
            if (err){
                reject(err);
            }
            else{
                resolve(dest_download);
            }
        });
    });
}

const generate_template = (module_name, path_template, dest_generate) => {
    const dest_tmp = path.join(dest_generate, module_name);
    generator(path_template, dest_tmp);
}

// Error handlers
const enhanceErrorMessages = (methodName, log) => {
  program.Command.prototype[methodName] = function (...args) {
    if (methodName === 'unknownOption' && this._allowUnknownOption) {
      return
    }
    this.outputHelp()
    console.log(`  ` + chalk.red(log(...args)))
    console.log()
    process.exit(1)
  }
}

enhanceErrorMessages('missingArgument', argName => {
  return `Missing required argument ${chalk.yellow(`<${argName}>`)}.`
})

enhanceErrorMessages('unknownOption', optionName => {
  return `Unknown option ${chalk.yellow(optionName)}.`
})

enhanceErrorMessages('optionMissingArgument', (option, flag) => {
  return `Missing required argument for option ${chalk.yellow(option.flags)}` + (
    flag ? `, got ${chalk.yellow(flag)}` : ``
  )
})

program.parse(process.argv)

if (!process.argv.slice(2).length) {
  program.outputHelp()
}
